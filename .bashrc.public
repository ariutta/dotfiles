# shellcheck disable=SC1090
# ██████╗ ██╗   ██╗██████╗ ██╗     ██╗ ██████╗     ██████╗ ███╗   ██╗██╗  ██╗   ██╗██╗
# ██╔══██╗██║   ██║██╔══██╗██║     ██║██╔════╝    ██╔═══██╗████╗  ██║██║  ╚██╗ ██╔╝██║
# ██████╔╝██║   ██║██████╔╝██║     ██║██║         ██║   ██║██╔██╗ ██║██║   ╚████╔╝ ██║
# ██╔═══╝ ██║   ██║██╔══██╗██║     ██║██║         ██║   ██║██║╚██╗██║██║    ╚██╔╝  ╚═╝
# ██║     ╚██████╔╝██████╔╝███████╗██║╚██████╗    ╚██████╔╝██║ ╚████║███████╗██║   ██╗
# ╚═╝      ╚═════╝ ╚═════╝ ╚══════╝╚═╝ ╚═════╝     ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝   ╚═╝
#                                                                                     
# Warning: this file will be made public online. Only include publicly shareable data.

# see README.md for details on purposes of .profile .profile.public .bashrc .bashrc.public .bash_profile


# TODO verify "-n" is the same as "--cmd 'set noswapfile'"
# TODO is there any benefit to using --cmd 'set dir=/tmp'?
# TODO: how about "backupskip"?
# NOTE: nobackup means delete backup file after a save.
#       nowritebackup means buffer -> new file, del original file, rename new file -> original file name. 
if $(LC_ALL=C type -t vimcognito >/dev/null); then
  # Don't clobber the variable or command
  echo "'vimcognito' already set" >&2
else
  alias vimcognito="vim -i NONE -u NONE -U NONE --noplugin -n --cmd 'set nobackup' --cmd 'set nowritebackup' --"
fi

# list the newest item in a directory
# https://stackoverflow.com/questions/1015678/get-most-recent-file-in-a-directory-on-linux#comment77652048_23034261
if $(LC_ALL=C type -t newest >/dev/null); then
  # Don't clobber the variable or command
  echo "'newest' already set" >&2
else
  newest ()
  {
    # TODO: use proper arg handling
    if [ "$1" = '-a' ]; then
      local NEWEST_CMD_ALL=1
      local NEWEST_CMD_TARGET_DIR="$2"
    elif [ "$2" = '-a' ]; then
      local NEWEST_CMD_ALL=1
      local NEWEST_CMD_TARGET_DIR="$1"
    else
      local NEWEST_CMD_ALL=0
      local NEWEST_CMD_TARGET_DIR="$1"
    fi

    # if target dir not specified, use cwd
    local NEWEST_CMD_TARGET_DIR=${NEWEST_CMD_TARGET_DIR:-"./"}

    local NEWEST_CMD_PREV_DIR="$(pwd)"

    # For git repos, I need to change to the target dir to make git ls-files work,
    # so I'm just doing it for all of them for consistency.
    cd "$NEWEST_CMD_TARGET_DIR"

    if [ $NEWEST_CMD_ALL -eq 1 ]; then
      # newest, looking at all files (including both hidden and non-hidden)
      echo "newest (looking at all files)" >&2
      find -- ./ -type f -printf "%T@ %TY-%Tm-%Td %TH:%TM %P\n" | sort -rn | head -n 5 | cut -d' ' -f 2-
    else
      # check whether we're in a git repo
      if git status >/dev/null 2>/dev/null; then
        # newest, excluding files ignored by git
        # but including those just untracked by git
        echo "newest (excluding files ignored by git)" >&2

        # tracked files: git ls-files
        # untracked files not ignored by git: git ls-files --others --exclude-standard

        # TODO: there's probably a better way to do this
        cat <(git ls-files) <(git ls-files --others --exclude-standard) |\
          xargs -I _ find -- ./ -type f -wholename "./_" -printf "%T@ %TY-%Tm-%Td %TH:%TM %P\n" |\
          sort -rn | head -n 5 | cut -d' ' -f 2-
      else
        # newest, excluding hidden files
        echo "newest (looking at non-hidden files only)" >&2
        find -- ./ -type f -not -path '*/\.*' -printf "%T@ %TY-%Tm-%Td %TH:%TM %P\n" | sort -rn | head -n 5 | cut -d' ' -f 2-
      fi
    fi

    cd "$NEWEST_CMD_PREV_DIR"
  }
fi
